# 设计模式

## <a name="index"/> 目录

* [性能模式](#performance)
  * [单件模式](#singleton)
  * [享元模式](#flyweight)
* [总结](#summery)


## <a name="performance"/> 性能模式

这类模式主要是为了解决对象的性能问题而生，并非组织问题，主要是 `单件模式` 和 `享元模式`

### <a name="singleton"/> 单件模式

* 动机
  - 在软件系统中，经常有这样一些特殊类，必须保证他们在系统中只存在一个实例才能确保逻辑正确、以及良好的效率。
  - 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例?
    - 应该是设计者的职责，而不是使用者的职责
* 定义
  - 保证一个类只有一个实例，并提供一个该实例的全局访问点。



**UML结构关系图**

```bash

    .---------------------.
    |  Singleton          |    
    |---------------------|   .-----------------------.
    |static Instance() o--+-->| return uniqueInstance |
    |SingletonOperation() |   '-----------------------'
    |GetSingletonData()   |   
    |---------------------|
    |static uniqueInstance|
    |singletonData        |
    '---------------------'

```

### <a name="flyweight"/> 享元模式


## <a name="summery"/> 总结

### 要点：

> 管理变化，提高复用

### 两个手段

> 分解 VS. 抽象


### 八大原则

* 依赖倒置原则 (DIP)
* 开放封闭原则 (OCP)
* 单一职责原则 (SRP)
* Liskov替换原则 (LSP)
* 接口隔离原则 (ISP)
* 对象组合优于类继承
* 封装变化点
* 面向接口编程

单件模式/享元模式 解决性能问题

### 重构技法

* 静态 -> 动态
* 早绑定 -> 晚绑定
* 继承 -> 组合
* 编译时依赖 -> 运行时依赖
* 紧耦合 -> 松耦合

技法以及原则相同，互相之间往往是相通的

### 从封装变化的角度对模式分类

* 组件协作
* 对象性能
* 单一职责
* 对象创建
* 接口隔离


下列模式，在现在可能不能满足了，有点过时了，或者在语言进化的过程中
* Builder 
* Mediator 
* Memento (现代语言，序列化会更容易和不易出错，所以也过时了)
* Iterator（C++等语言，模板泛型的支持内置了）
* Chain Of Responsibility 
* Visitor （脆弱，不能轻易使用）
* Command(C++ Functor 语言级别就支持了) 
* Interpreter（OOP不适用了，有专门的解析器）

>  把模式UML图，class名改为A/B/C,方法名改为F1()/F2()/...，忘掉模式的名字

C++中，继承和组合，性能差不多（内存模型类似）
但是组合的是对象，不是对象指针，那么，还是一个紧耦合。
如果放的是组合是通过指针来关联，则可以泛化，松耦合。
通过指针指向多态对象，来拥抱变化，是松耦合基础。


### 一个目标

关注变化点和稳定点

### 什么时候不用模式

* 代码可读性很差时 (最基础的代码质量)
* 需求理解还很浅时 
* 变化没有显现时 
* 不是系统的关键依赖点 
* 项目没有复用价值时 
* 项目将要发布时 

例如，不是很常用的外包软件，没有复用价值时，就没有必要用设计模式

### 经验之谈

* 不要为了模式而模式
* 关注抽象类 & 接口
* 理清变化点和稳定点
* 审视依赖关系
* 要有Framework 和 Application 的区隔思维
* 良好的设计是演化的结果(不是一步到位)
 
### 设计模式成长之路

* “手中无剑，心中无剑”：见模式而不知
* “手中有剑，心中无剑”: 可以识别模式，作为应用开发人员使用模式
* “手中有剑，心中有剑”: 作为框架开发人员为应用设计某些模式
* “手中无剑，心中有剑”: 忘掉模式，只有原则

